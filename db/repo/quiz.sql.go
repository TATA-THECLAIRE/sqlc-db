// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quiz.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (quiz_id, question_text, option_a, option_b, option_c, option_d, correct_answer)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, quiz_id, question_text, option_a, option_b, option_c, option_d, correct_answer, created_at
`

type CreateQuestionParams struct {
	QuizID        string `json:"quiz_id"`
	QuestionText  string `json:"question_text"`
	OptionA       string `json:"option_a"`
	OptionB       string `json:"option_b"`
	OptionC       string `json:"option_c"`
	OptionD       string `json:"option_d"`
	CorrectAnswer string `json:"correct_answer"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.QuizID,
		arg.QuestionText,
		arg.OptionA,
		arg.OptionB,
		arg.OptionC,
		arg.OptionD,
		arg.CorrectAnswer,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.QuestionText,
		&i.OptionA,
		&i.OptionB,
		&i.OptionC,
		&i.OptionD,
		&i.CorrectAnswer,
		&i.CreatedAt,
	)
	return i, err
}

const createQuiz = `-- name: CreateQuiz :one
INSERT INTO quizzes (title, description)
VALUES ($1, $2)
RETURNING id, title, description, created_at
`

type CreateQuizParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
}

func (q *Queries) CreateQuiz(ctx context.Context, arg CreateQuizParams) (Quiz, error) {
	row := q.db.QueryRow(ctx, createQuiz, arg.Title, arg.Description)
	var i Quiz
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createQuizAttempt = `-- name: CreateQuizAttempt :one
INSERT INTO quiz_attempts (quiz_id, user_name, score, total_questions)
VALUES ($1, $2, $3, $4)
RETURNING id, quiz_id, user_name, score, total_questions, created_at
`

type CreateQuizAttemptParams struct {
	QuizID         string `json:"quiz_id"`
	UserName       string `json:"user_name"`
	Score          int32  `json:"score"`
	TotalQuestions int32  `json:"total_questions"`
}

func (q *Queries) CreateQuizAttempt(ctx context.Context, arg CreateQuizAttemptParams) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, createQuizAttempt,
		arg.QuizID,
		arg.UserName,
		arg.Score,
		arg.TotalQuestions,
	)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserName,
		&i.Score,
		&i.TotalQuestions,
		&i.CreatedAt,
	)
	return i, err
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, quiz_id, question_text, option_a, option_b, option_c, option_d, correct_answer, created_at FROM questions
WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id string) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.QuestionText,
		&i.OptionA,
		&i.OptionB,
		&i.OptionC,
		&i.OptionD,
		&i.CorrectAnswer,
		&i.CreatedAt,
	)
	return i, err
}

const getQuestionsByQuizID = `-- name: GetQuestionsByQuizID :many
SELECT id, quiz_id, question_text, option_a, option_b, option_c, option_d, created_at
FROM questions
WHERE quiz_id = $1
ORDER BY created_at
`

type GetQuestionsByQuizIDRow struct {
	ID           string           `json:"id"`
	QuizID       string           `json:"quiz_id"`
	QuestionText string           `json:"question_text"`
	OptionA      string           `json:"option_a"`
	OptionB      string           `json:"option_b"`
	OptionC      string           `json:"option_c"`
	OptionD      string           `json:"option_d"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionsByQuizID(ctx context.Context, quizID string) ([]GetQuestionsByQuizIDRow, error) {
	rows, err := q.db.Query(ctx, getQuestionsByQuizID, quizID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionsByQuizIDRow{}
	for rows.Next() {
		var i GetQuestionsByQuizIDRow
		if err := rows.Scan(
			&i.ID,
			&i.QuizID,
			&i.QuestionText,
			&i.OptionA,
			&i.OptionB,
			&i.OptionC,
			&i.OptionD,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizAttemptsByQuizID = `-- name: GetQuizAttemptsByQuizID :many
SELECT id, quiz_id, user_name, score, total_questions, created_at FROM quiz_attempts
WHERE quiz_id = $1
ORDER BY score DESC, created_at DESC
`

func (q *Queries) GetQuizAttemptsByQuizID(ctx context.Context, quizID string) ([]QuizAttempt, error) {
	rows, err := q.db.Query(ctx, getQuizAttemptsByQuizID, quizID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuizAttempt{}
	for rows.Next() {
		var i QuizAttempt
		if err := rows.Scan(
			&i.ID,
			&i.QuizID,
			&i.UserName,
			&i.Score,
			&i.TotalQuestions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuizByID = `-- name: GetQuizByID :one
SELECT id, title, description, created_at FROM quizzes
WHERE id = $1
`

func (q *Queries) GetQuizByID(ctx context.Context, id string) (Quiz, error) {
	row := q.db.QueryRow(ctx, getQuizByID, id)
	var i Quiz
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listQuizzes = `-- name: ListQuizzes :many
SELECT id, title, description, created_at FROM quizzes
ORDER BY created_at DESC
`

func (q *Queries) ListQuizzes(ctx context.Context) ([]Quiz, error) {
	rows, err := q.db.Query(ctx, listQuizzes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quiz{}
	for rows.Next() {
		var i Quiz
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
